#include <Arduino_LSM9DS1.h> // 根据您的传感器类型调整
#include <TensorFlowLite.h>
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/micro_log.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/schema/schema_generated.h"

// 【修改】现在只导入编码器模型，不再导入完整的autoencoder
#include "encoder_model.h" 

// ======================================================================
//             >>> 从 Colab 脚本复制粘贴的 C++ 参数 <<<
// ======================================================================
// --- 数据预处理参数 ---
// 请替换为您的 Colab 脚本输出的实际值
const float scaler_mean[3] = { -0.008062962009488434f, -0.020294950535103527f, 1.0164002795042475f };
const float scaler_scale[3] = { 0.0077848401950793835f, 0.037119756206916155f, 0.004799918469097551f };
const float pca_components[3] = { 0.2717441475008236f, 0.766907456863307f, 0.5813846152991198f };

// --- 模型结构参数 ---
const int DENSE1_UNITS = 16;
const int EMBEDDING_UNITS = 4; // 编码器输出维度
const int DECODER_DENSE1_UNITS = 16; // 解码器第一层维度
const int WINDOW_SIZE = 40; // 窗口大小

// --- 解码器第一层 (decoder_dense1) 的固定权重和偏置 ---
// 权重形状 (EMBEDDING_UNITS, DECODER_DENSE1_UNITS) -> (4, 16)
const float decoder_dense1_weights[64] = 
{
-0.11828311532735825f, 0.14782869815826416f, 0.5496509075164795f, -0.11288230866193771f, 
-0.3384092152118683f,  0.2984302043914795f,  0.3897485136985779f,  0.32390686869621277f, 
 0.4867933988571167f, -0.207697793841362f, 0.4932819902896881f, -0.07171362638473511f, 
 -0.1696804314851761f, -0.131270170211792f, 0.027390673756599426f, 0.5622674822807312f, 
 0.07233182340860367f, 0.264460027217865f, 0.02716580033302307f, 0.3458288609981537f, 
 0.25816047191619873f, -0.37554195523262024f, -0.12044785171747208f, 0.5849164724349976f, 
 -0.4218776524066925f, -0.11944594979286194f, 0.06889510154724121f, -0.8138277530670166f, 
 0.06255307048559189f, 0.09228634089231491f, 0.24321721494197845f, -0.5417048335075378f, 
 0.5534453988075256f, 0.184994637966156f, 0.023065848276019096f, 0.32864782214164734f, 
 0.15335296094417572f, 0.45197436213493347f, 0.1198878139257431f, -0.2845034897327423f, 
 0.2665301561355591f, -0.0958094671368599f, -0.8951881527900696f, -0.24361690878868103f, 
 0.06058917194604874f, 0.004169914871454239f, -0.13485895097255707f, 0.5410026907920837f, 
 -0.32521945238113403f, -0.5636677742004395f, 0.1679588258266449f, -0.29938891530036926f, 
 0.23212294280529022f, 0.4032636880874634f, 0.18335478007793427f, -0.16416002810001373f, 
 -0.23679684102535248f, 0.46048277616500854f, 0.33021196722984314f, 0.6403264403343201f, 
 0.18638673424720764f, 0.15387484431266785f, 0.057581380009651184f, -0.20960380136966705f
};

// 偏置形状 (DECODER_DENSE1_UNITS,) -> (16,)
const float decoder_dense1_bias[16] = 
{
0.5756975412368774f, 0.6421185731887817f, -0.26108747720718384f, -0.6135280132293701f, 
-0.7728652358055115f, -0.9457443952560425f, 0.32041484117507935f, -0.6864877343177795f, 
-0.4228132665157318f, 0.6976213455200195f, 1.105565071105957f, 0.4001907408237457f, 
0.15070466697216034f, 0.17449836432933807f, 0.2552036941051483f, 0.948433518409729f
};

// --- 解码器第二层 (decoder_dense2) 的固定权重和【可训练】偏置 ---
// 权重形状 (DECODER_DENSE1_UNITS, WINDOW_SIZE) -> (16, 40)
float trainable_decoder_dense2_weights[640] = 
{
0.4915127158164978f, 0.07702696323394775f, -0.5313659906387329f, 0.32648172974586487f, 
0.21638815104961395f, -0.5399091839790344f, 0.3016498386859894f, 0.19275210797786713f, 
-0.364987313747406f, 0.11376623809337616f, 0.31384673714637756f, -0.2324369251728058f, 
0.04007397219538689f, 0.5243520140647888f, -0.09565654397010803f, -0.021430205553770065f, 
0.5328642129898071f, -0.02245800569653511f, -0.026581352576613426f, 0.5612789392471313f, 
0.11476045846939087f, -0.06252701580524445f, 0.5707380175590515f, 0.1382845938205719f, 
-0.07252330332994461f, 0.6214165687561035f, 0.22860406339168549f, -0.1652345359325409f,
0.5937411189079285f, 0.23527906835079193f, -0.1937418133020401f, 0.5296558141708374f, 
0.2745018005371094f, -0.3460312783718109f, 0.3582228422164917f, 0.15897037088871002f, 
-0.4562019109725952f, 0.2988893687725067f, 0.17642317712306976f, -0.46700310707092285f, 
-0.0006186343962326646f, 0.022768119350075722f, 0.6305333375930786f, 0.09131834656000137f, 
-0.019477199763059616f, 0.7053555846214294f, 0.050548113882541656f, 0.018169883638620377f, 
0.5504103302955627f, -0.020491929724812508f, -0.0047442917712032795f, 0.33052271604537964f, 
-0.14205458760261536f, -0.05604733154177666f, 0.1198883205652237f, -0.37886083126068115f, 
-0.029469775035977364f, -0.057862602174282074f, -0.5907511711120605f, -0.03165072575211525f, 
-0.17450550198554993f, -0.7122638821601868f, -0.026820985600352287f, -0.18891990184783936f, 
-0.7480911016464233f, -0.05144317075610161f, -0.17387935519218445f, -0.6940687894821167f, 
-0.03836885094642639f, -0.0741950199007988f, -0.575594961643219f, -0.025947559624910355f, 
0.08664698153734207f, -0.3350371718406677f, -0.018023395910859108f, 0.24700108170509338f, 
-0.09862763434648514f, 0.026603324338793755f, 0.33777207136154175f, 0.03127167373895645f, 
0.03422008454799652f, 0.025319010019302368f, -0.39125266671180725f, -0.061071328818798065f, 
-0.06125442683696747f, -0.23264852166175842f, -0.2573185861110687f, -0.28908711671829224f, 
-0.20866034924983978f, -0.2934085726737976f, -0.1443350911140442f, -0.19222648441791534f, 
-0.38979095220565796f, -0.0035676471889019012f, -0.2546498775482178f, -0.3633115589618683f, 
-0.1398565173149109f, 0.11863288283348083f, -0.12366510927677155f, -0.2665684223175049f, 
-0.07446431368589401f, -0.2263922542333603f, -0.2802247703075409f, 0.13769292831420898f, 
-0.08977413177490234f, -0.18247483670711517f, -0.028707748278975487f, 0.04964747652411461f, 
0.09151570498943329f, 0.13822931051254272f, 0.518855094909668f, -0.12172122299671173f, 
-0.09481222927570343f, 0.5134235620498657f, -0.20360067486763f, -0.37795719504356384f, 
0.4918782413005829f, -0.2719173729419708f, -0.20065467059612274f, 0.41020825505256653f, 
-0.22883543372154236f, 0.6450668573379517f, -0.12084976583719254f, -0.1525857150554657f, 
0.6390655636787415f, 0.010845877230167389f, -0.3258819282054901f, 0.5606421828269958f, 
0.22054822742938995f, -0.5089698433876038f, 0.39746618270874023f, 0.2564423084259033f, 
-0.5616543889045715f, 0.1101592555642128f, 0.3145933449268341f, -0.45952630043029785f, 
-0.09742184728384018f, 0.3294150233268738f, -0.21972443163394928f, -0.17698980867862701f, 
0.22863095998764038f, -0.21047665178775787f, -0.2596704363822937f, 0.09295468777418137f, 
-0.19774141907691956f, -0.37652134895324707f, -0.038920726627111435f, -0.08873484283685684f, 
-0.23811456561088562f, 0.021342579275369644f, -0.14276857674121857f, 0.007113534491509199f, 
-0.093099445104599f, -0.3464834690093994f, 0.28083768486976624f, 0.1798263043165207f, 
-0.2977953255176544f, 0.19349166750907898f, 0.2520831525325775f, -0.11718504130840302f, 
-0.1016135960817337f, 0.258922815322876f, 0.5565359592437744f, -0.12122698873281479f, 
0.17579665780067444f, 0.47879645228385925f, -0.11343811452388763f, -0.037235431373119354f, 
0.29109328985214233f, -0.181784525513649f, -0.20804370939731598f, -0.05392163619399071f, 
-0.17860165238380432f, -0.30157071352005005f, -0.23757584393024445f, -0.30149999260902405f,
 -0.26325464248657227f, -0.5390062928199768f, -0.43620169162750244f, -0.15402773022651672f, 
 -0.5117225646972656f, -0.4630658030509949f, 0.0068375179544091225f, -0.4807130694389343f, 
 -0.4469130337238312f, 0.11332173645496368f, -0.2390955686569214f, -0.30040818452835083f, 
 0.22056689858436584f, -0.005434312392026186f, -0.07237711548805237f, 0.2753629982471466f, 
 0.2697278559207916f, 0.20365118980407715f, 0.21684032678604126f, 0.4662546217441559f, 
 0.4015694260597229f, 0.12739786505699158f, 0.4844306409358978f, 0.38861343264579773f, 
 -0.1152755618095398f, -0.22975584864616394f, 0.6603463292121887f, -0.07874207943677902f, 
 -0.13607266545295715f, 0.7191175818443298f, -0.021601306274533272f, -0.09242603182792664f, 
 0.6934412717819214f, 0.010270506143569946f, -0.04459097981452942f, 0.5178301334381104f, 
 0.055530767887830734f, -0.0025079352781176567f, 0.27545487880706787f, 0.09198278933763504f, 
 0.01874011754989624f, -0.027102116495370865f, 0.11399539560079575f, 0.06517398357391357f, 
 -0.3236789107322693f, 0.05189436674118042f, 0.10197658836841583f, -0.5779205560684204f, 
 -0.04448346048593521f, 0.11812955141067505f, -0.7295389771461487f, -0.16780740022659302f, 
 0.14489412307739258f, -0.7426018118858337f, -0.27429986000061035f, 0.17160126566886902f, 
 -0.6738113164901733f, -0.39542311429977417f, 0.17224285006523132f, -0.5196751952171326f, 
 -0.4226713180541992f, 0.1612071394920349f, -0.32582011818885803f, -0.34791648387908936f, 
 -0.03293665125966072f, -0.40559807419776917f, -0.23463138937950134f, -0.05749469995498657f, 
 -0.34309327602386475f, -0.4553797245025635f, -0.017205912619829178f, 0.00878299679607153f, 
 -0.44118624925613403f, -0.0706285834312439f, -0.08377966284751892f, -0.29116278886795044f, 
 -0.018614953383803368f, -0.2180042415857315f, -0.013132601976394653f, -0.038444604724645615f, 
 0.011274146847426891f, -0.24605795741081238f, -0.2552248239517212f, 0.16740497946739197f, 
 0.12658296525478363f, 0.08241500705480576f, 0.17665207386016846f, -0.07210125774145126f, 
 0.21943676471710205f, 0.08307385444641113f, 0.07907513529062271f, 0.3775838315486908f, 
 -0.25063860416412354f, -0.2923714220523834f, 0.09630782157182693f, 0.005237175617367029f, 
 -0.23346713185310364f, 0.3426467478275299f, 0.13039694726467133f, -0.11149481683969498f, 
 0.43971124291419983f, 0.21139442920684814f, -0.48707881569862366f, 0.40692445635795593f, 
 -0.6509721875190735f, -0.032674532383680344f, 0.06447509676218033f, -0.5538914799690247f, 
 0.007201503496617079f, 0.07456865161657333f, -0.4558512270450592f, 0.09207747876644135f, 
 0.061477143317461014f, -0.32848501205444336f, 0.1570698320865631f, 0.005614233203232288f, 
 -0.1634708195924759f, 0.19587206840515137f, -0.007666486315429211f, -0.021204466000199318f, 
 0.2050425410270691f, 0.014975632540881634f, 0.13090543448925018f, 0.1793615221977234f, 
 0.03927743062376976f, 0.13222210109233856f, 0.0667043924331665f, 0.04259469360113144f, 
 0.06077440455555916f, -0.15366284549236298f, 0.04775898531079292f, -0.006121605634689331f, 
 -0.3597782552242279f, 0.08089776337146759f, -0.18128807842731476f, -0.56485915184021f, 
 0.06813880056142807f, -0.2950040400028229f, -0.618375837802887f, 0.17924527823925018f, 
 -0.29315558075904846f, -0.6426676511764526f, 0.22551129758358002f, -0.21319182217121124f, 
 -0.013407167047262192f, -0.4741360545158386f, 0.30756163597106934f, -0.04794687405228615f, 
 -0.3911336660385132f, 0.516642689704895f, -0.13864769041538239f, -0.2360963076353073f, 
 0.7329393029212952f, -0.2538590133190155f, -0.044253453612327576f, 0.8616219162940979f, 
 -0.31869104504585266f, 0.11508405208587646f, 0.8735623359680176f, -0.30846884846687317f, 
 0.17231719195842743f, 0.8153530955314636f, -0.2199152261018753f, 0.22042080760002136f, 
 0.598709762096405f, -0.19634591042995453f, 0.21808752417564392f, 0.3096406161785126f, 
 -0.15671038627624512f, 0.1771516352891922f, -0.018233127892017365f, -0.11205385625362396f, 
 0.15258923172950745f, -0.26320505142211914f, -0.12529140710830688f, 0.11701866239309311f, 
 -0.4848209619522095f, -0.18275147676467896f, 0.10412976145744324f, -0.5292035937309265f, 
 -0.1307399719953537f, 0.03866343945264816f, -0.454785019159317f, 0.05003279447555542f, 
 0.1552271693944931f, -0.18676553666591644f, 0.2957965135574341f, 0.38946259021759033f, 
 0.03092212788760662f, 0.23423701524734497f, 0.5692048072814941f, -0.010386507958173752f, 
 0.3869228661060333f, 0.4033676087856293f, 0.08166928589344025f, 0.19918489456176758f, 
 0.4338519275188446f, 0.1612253338098526f, 0.21186348795890808f, 0.4643893539905548f, 
 0.013890111818909645f, 0.12006646394729614f, 0.6993271708488464f, 0.004836521577090025f, 
 0.16313184797763824f, 0.5724799633026123f, -0.1081978976726532f, 0.008518632501363754f, 
 0.48983046412467957f, -0.37862855195999146f, -0.027352211996912956f, 0.5491198897361755f, 
 -0.4016363024711609f, 0.06414486467838287f, 0.5279639959335327f, -0.32894667983055115f, 
 -0.08588339388370514f, 0.16724666953086853f, -0.15487079322338104f, 0.044249456375837326f, 
 0.15813954174518585f, -0.1275426298379898f, 0.0705845057964325f, 0.37461912631988525f, 
 0.27690771222114563f, -0.14940115809440613f, 0.45993682742118835f, 0.4226292073726654f, 
 -0.2820587158203125f, 0.49218788743019104f, 0.43400663137435913f, -0.47327232360839844f, 
 0.4482172429561615f, 0.36536702513694763f, -0.6504697799682617f, 0.3089953064918518f, 
 0.30476388335227966f, -0.7676504254341125f, 0.17883747816085815f, 0.18253841996192932f, 
 -0.8307619690895081f, 0.06171414628624916f, 0.10789229720830917f, -0.7843692302703857f, 
 -0.01932516321539879f, -0.016567271202802658f, -0.6616546511650085f, -0.0586712583899498f, 
 -0.1270824372768402f, -0.5018962621688843f, -0.03722250834107399f, -0.19701793789863586f, 
 -0.25014984607696533f, 0.07389316707849503f, -0.25530320405960083f, 0.0030967548955231905f, 
 0.15507207810878754f, -0.28767338395118713f, 0.19338148832321167f, 0.25194206833839417f, 
 -0.23124870657920837f, 0.276515930891037f, 0.2531808614730835f, -0.12593461573123932f, 
 0.13771870732307434f, -0.242677703499794f, 0.2717660069465637f, -0.09568335115909576f, 
 -0.4239550530910492f, 0.2591489851474762f, -0.1868552565574646f, -0.6163750290870667f, 
 0.21744324266910553f, -0.2435322403907776f, -0.6894948482513428f, 0.2058151811361313f, 
 -0.29270344972610474f, -0.641240656375885f, 0.13365614414215088f, -0.2767484188079834f, 
 -0.5037795901298523f, 0.058195628225803375f, -0.303533136844635f, -0.3120047152042389f, 
 0.039343688637018204f, -0.183140829205513f, -0.04013153910636902f, 0.08012054115533829f, 
 -0.056234922260046005f, 0.30138078331947327f, 0.14309485256671906f, -0.03314422070980072f, 
 0.46970313787460327f, 0.11479254812002182f, 0.08775115013122559f, 0.5283744931221008f, 
 0.17432890832424164f, 0.21519318222999573f, 0.3861865699291229f, -0.02495911903679371f, 
 0.20373158156871796f, 0.2668439745903015f, -0.12307140231132507f, 0.12243849784135818f, 
 0.11509104073047638f, 0.21366414427757263f, -0.10620085150003433f, 0.042903315275907516f, 
 0.04898538067936897f, 0.21948125958442688f, -0.025355655699968338f, 0.31289201974868774f,
 0.05745531618595123f, 0.213210329413414f, 0.42034462094306946f, 0.19253870844841003f, 
 -0.02235066518187523f, 0.4366896152496338f, 0.11913525313138962f, -0.05545821040868759f, 
 0.1526433825492859f, 0.2792327105998993f, 0.15866874158382416f, 0.07047746330499649f, 
 0.06268052756786346f, 0.35242870450019836f, 0.0886923298239708f, 0.2629009485244751f, 
 0.10981868207454681f, 0.13455452024936676f, -0.03561598062515259f, 0.22190415859222412f, 
 0.2296389937400818f, 0.017468255013227463f, 0.25590780377388f, -0.15168578922748566f, 
 -0.07998502254486084f, 0.46040332317352295f, -0.006244632415473461f, -0.1034630835056305f, 
 0.22130034863948822f, 0.07122756540775299f, -0.05800177529454231f, 0.25102856755256653f, 
 0.0653814822435379f, 0.08995546400547028f, 0.17160752415657043f, 0.1855621188879013f, 
 0.03319138288497925f, 0.11884795129299164f, -0.18904215097427368f, 0.2468193918466568f, 
 -0.06103361025452614f, -0.13085401058197021f, 0.319365918636322f, 0.1853218376636505f, 
 0.1283910572528839f, 0.1944931000471115f, 0.052516110241413116f, 0.20416517555713654f, 
 0.6251100301742554f, 0.5133649110794067f, -0.06206329166889191f, 0.3998072147369385f, 
 0.3137679100036621f, -0.15862900018692017f, 0.15302090346813202f, 0.4016682207584381f,
 0.40949109196662903f, 0.08036737889051437f, 0.31729379296302795f, 0.16031956672668457f, 
 -0.07622220367193222f, 0.06247459352016449f, 0.03105568140745163f, 0.07620750367641449f, 
 0.048169542104005814f, 0.12976299226284027f, -0.061989739537239075f, -0.14233039319515228f, 
 0.454205721616745f, 0.10357478260993958f, 0.04442552477121353f, 0.10292910039424896f, 
 -0.14028134942054749f, 0.10281259566545486f, 0.10907888412475586f, -0.44180163741111755f, 
 0.22574009001255035f, -0.14692094922065735f, -0.08978637307882309f, 0.11748760938644409f, 
 0.012521040625870228f, -0.02353050746023655f, -0.04027153179049492f, 0.22879959642887115f, 
 0.01188121922314167f, -0.0027770488522946835f, 0.46292734146118164f, 0.07188326120376587f, 
 -0.12480831146240234f, 0.14754852652549744f, -0.111136794090271f, -0.11774003505706787f, 
 0.44558092951774597f, 0.23462355136871338f, -0.12998215854167938f, 0.29136788845062256f, 
 0.30213063955307007f, 0.042681824415922165f, 0.4813433885574341f, 0.26717042922973633f, 
 -0.16707809269428253f, 0.20020101964473724f, 0.2782323658466339f, -0.04078033193945885f, 
 0.35456815361976624f, 0.326300710439682f, -0.28037920594215393f, 0.011967601254582405f, 
 0.003837410593405366f, -0.2371249943971634f, -0.3627769351005554f, -0.12883520126342773f, 
 0.1101541817188263f, 0.48648717999458313f, -0.2921088933944702f, 0.18887576460838318f, 
 0.4271041452884674f, -0.4542325735092163f, 0.2694770395755768f, 0.30645552277565f, 
 -0.6494768261909485f, 0.3589642345905304f, 0.15526074171066284f, -0.7610469460487366f, 
 0.38265714049339294f, 0.019666938111186028f, -0.7853063941001892f, 0.34655100107192993f, 
 -0.04700180143117905f, -0.7094777226448059f, 0.2434481829404831f, -0.10446958243846893f, 
 -0.5280666351318359f, 0.15320393443107605f, -0.12971147894859314f, -0.24455676972866058f, 
 0.05721273645758629f, -0.11817590892314911f, 0.051111962646245956f, -0.05883387103676796f, 
 -0.09847449511289597f, 0.32145750522613525f, -0.12508884072303772f, -0.06541973352432251f, 
 0.5524457693099976f, -0.15059718489646912f, -0.04929511621594429f, 0.6476647257804871f, 
 -0.20417892932891846f, 0.01747020147740841f, 0.629919707775116f, -0.3078451156616211f
};

// 可训练偏置形状 (WINDOW_SIZE,) -> (40,)
// 注意这里是 `float` 而不是 `const float`，因为我们需要在运行时修改它
float trainable_decoder_dense2_bias[40] = 
{
0.2760811448097229f, -0.3354102075099945f, -0.8097547888755798f, 0.33381208777427673f, 
-0.487807035446167f, -0.6203367710113525f, 0.30510976910591125f, -0.5292578935623169f, 
-0.40329092741012573f, 0.5818504691123962f, -0.2761000692844391f, -0.09917670488357544f, 
0.629242479801178f, -0.08553993701934814f, 0.16701048612594604f, 0.7216334342956543f, 
0.14994075894355774f, 0.6147249937057495f, 0.6986811757087708f, 0.31244418025016785f, 
0.5751761198043823f, 0.3731826841831207f, 0.4824352264404297f, 0.7186706066131592f, 
0.049389615654945374f, 0.585964560508728f, 0.4822959005832672f, -0.19531327486038208f, 
0.7038112878799438f, 0.3944171965122223f, -0.22972001135349274f, 0.37779027223587036f, 
-0.02640501596033573f, -0.36590516567230225f, 0.2999626696109772f, -0.3030260503292084f, 
-0.47931694984436035f, 0.07563231885433197f, -0.3310701251029968f, -0.5141077041625977f
};

// --- 异常检测阈值 ---
// 请替换为您的 Colab 脚本输出的实际值
const float ANOMALY_THRESHOLD = 3.0f; // 基于99百分位数，请用您的实际值替换

// ======================================================================
//             >>> TFLite Micro 和在线学习相关配置 <<<
// ======================================================================

// TFLite Micro 解释器和模型相关变量
const tflite::Model* encoder_model = nullptr;
tflite::MicroInterpreter* encoder_interpreter = nullptr;
TfLiteTensor* encoder_input = nullptr;
TfLiteTensor* encoder_output = nullptr;

// 分配的内存大小，根据模型复杂性调整
// ！！！ 注意 ！！！ 如果出现内存不足错误，请增大 kTensorArenaSize
// 同时，runOnlineLearning() 函数中的梯度累加器也占用内存，如果内存紧张，需要优化
constexpr int kTensorArenaSize = 8 * 1024; // 8KB，如果不够，请增大
uint8_t tensor_arena[kTensorArenaSize];

// 传感器数据缓冲区
float sensor_data_window[WINDOW_SIZE][3]; // 存储原始x, y, z数据
int window_index = 0; // 当前窗口的写入位置
bool window_is_full = false;

// PCA降维后的数据缓冲区 (窗口化)
float pca_data_window[WINDOW_SIZE];

// 编码器输出（嵌入向量）
float embedding_output[EMBEDDING_UNITS];

// 解码器中间层和输出层
float decoder_dense1_output[DECODER_DENSE1_UNITS];
float reconstructed_output[WINDOW_SIZE]; // 重建的1D PCA数据

// 在线学习参数
// ！！！ 注意 ！！！ 由于现在更新权重，可能需要调整 LEARNING_RATE
const float LEARNING_RATE = 0.0000001f; // 学习率，更新权重可能需要更小的值
const float LEARN_THRESHOLD_FACTOR = 0.8f; // 只有当MAE小于ANOMALY_THRESHOLD的某个比例时才进行学习
const int LEARN_BATCH_SIZE = 25; // 累积多少个合格样本后进行一次学习
float learning_mae_buffer[LEARN_BATCH_SIZE];
float learning_embedding_buffer[LEARN_BATCH_SIZE][EMBEDDING_UNITS];
float learning_pca_data_buffer[LEARN_BATCH_SIZE][WINDOW_SIZE];
int learning_buffer_index = 0;

// ======================================================================
//                          >>> 辅助函数 <<<
// ======================================================================

// ReLU 激活函数
float relu(float x) {
    return (x > 0) ? x : 0;
}

// 数据预处理: 标准化和PCA降维
// input_x, input_y, input_z: 原始传感器读数
// output_pca_value: 降维后的1D值
void preprocess_data(float input_x, float input_y, float input_z, float& output_pca_value) {
    // 1. 标准化
    float scaled_x = (input_x - scaler_mean[0]) / scaler_scale[0];
    float scaled_y = (input_y - scaler_mean[1]) / scaler_scale[1];
    float scaled_z = (input_z - scaler_mean[2]) / scaler_scale[2];

    // 2. PCA 降维到1维
    output_pca_value = scaled_x * pca_components[0] +
                       scaled_y * pca_components[1] +
                       scaled_z * pca_components[2];
}

// 运行编码器
void run_encoder() {
    // 将 pca_data_window 复制到编码器输入张量
    for (int i = 0; i < WINDOW_SIZE; ++i) {
        encoder_input->data.f[i] = pca_data_window[i];
    }

    // 运行解释器
    TfLiteStatus invoke_status = encoder_interpreter->Invoke();
    if (invoke_status != kTfLiteOk) {
        MicroPrintf("Encoder invoke failed.\n");
        return;
    }

    // 从编码器输出张量复制结果到 embedding_output
    for (int i = 0; i < EMBEDDING_UNITS; ++i) {
        embedding_output[i] = encoder_output->data.f[i];
    }
}

// 运行解码器 (手动C++实现)
// ！！！ 重要修改 ！！！ 使用 trainable_decoder_dense2_weights
void run_decoder() {
    // 1. 解码器第一层 (Dense, ReLU)
    // 输入: embedding_output (EMBEDDING_UNITS)
    // 输出: decoder_dense1_output (DECODER_DENSE1_UNITS)
    for (int i = 0; i < DECODER_DENSE1_UNITS; ++i) {
        float sum = decoder_dense1_bias[i]; // 加上偏置
        for (int j = 0; j < EMBEDDING_UNITS; ++j) {
            // 权重存储为 (EMBEDDING_UNITS, DECODER_DENSE1_UNITS) 形状
            sum += embedding_output[j] * decoder_dense1_weights[j * DECODER_DENSE1_UNITS + i];
        }
        decoder_dense1_output[i] = relu(sum); // 应用ReLU激活函数
    }

    // 2. 解码器第二层 (Dense, Linear)
    // 输入: decoder_dense1_output (DECODER_DENSE1_UNITS)
    // 输出: reconstructed_output (WINDOW_SIZE)
    for (int i = 0; i < WINDOW_SIZE; ++i) {
        float sum = trainable_decoder_dense2_bias[i]; // 加上可训练偏置
        for (int j = 0; j < DECODER_DENSE1_UNITS; ++j) {
            // 权重存储为 (DECODER_DENSE1_UNITS, WINDOW_SIZE) 形状
            // ！！！ 重要修改 ！！！ 使用 trainable_decoder_dense2_weights
            sum += decoder_dense1_output[j] * trainable_decoder_dense2_weights[j * WINDOW_SIZE + i];
        }
        reconstructed_output[i] = sum; // 线性激活函数（无激活）
    }
}

// 计算平均绝对误差 (MAE)
float calculate_mae(const float* original, const float* reconstructed, int size) {
    float mae = 0.0f;
    for (int i = 0; i < size; ++i) {
        mae += fabsf(original[i] - reconstructed[i]);
    }
    return mae / size;
}

// 打印可训练偏置和部分权重 (用于调试)
// ！！！ 修改 ！！！ 增加打印权重部分
void printTrainableBias() {
    Serial.print("Current Trainable Bias (first 5 values): ");
    for (int i = 0; i < 5 && i < WINDOW_SIZE; ++i) {
        Serial.print(trainable_decoder_dense2_bias[i], 6);
        Serial.print(" ");
    }
    Serial.println();

    Serial.print("Current Trainable Weights (first 5 values of first row): ");
    for (int i = 0; i < 5 && i < WINDOW_SIZE; ++i) { // 打印第一行（对应 decoder_dense1_output[0] 的权重）的前5个值
        Serial.print(trainable_decoder_dense2_weights[i], 6);
        Serial.print(" ");
    }
    Serial.println();
}

// ！！！ 重大修改 ！！！ 在线微调解码器最后一层的权重和偏置
void runOnlineLearning() { // 函数名已修改
    MicroPrintf("Running online learning with %d samples (weights and bias). Estimated LEARNING_RATE: %.7f\n", LEARN_BATCH_SIZE, LEARNING_RATE);

    // 梯度累加器，初始化为0
    float gradient_weights_sum[DECODER_DENSE1_UNITS * WINDOW_SIZE] = {0.0f};
    float gradient_bias_sum[WINDOW_SIZE] = {0.0f};

    // 遍历批次中的每个样本
    for (int b = 0; b < LEARN_BATCH_SIZE; ++b) {
        // 1. 重新计算该样本的 decoder_dense1_output
        // 这是 decoder_dense2 层的输入，我们需要它来计算权重梯度
        float current_decoder_dense1_output_for_batch_sample[DECODER_DENSE1_UNITS];
        for (int k = 0; k < DECODER_DENSE1_UNITS; ++k) {
            float sum = decoder_dense1_bias[k];
            for (int j = 0; j < EMBEDDING_UNITS; ++j) {
                sum += learning_embedding_buffer[b][j] * decoder_dense1_weights[j * DECODER_DENSE1_UNITS + k];
            }
            current_decoder_dense1_output_for_batch_sample[k] = relu(sum);
        }

        // 2. 遍历解码器第二层的每个输出维度 (即重建输出的每个点)
        for (int i = 0; i < WINDOW_SIZE; ++i) {
            // 计算当前权重和偏置下的该输出维度 i 的重建值
            float current_reconstructed_i = trainable_decoder_dense2_bias[i];
            for (int j = 0; j < DECODER_DENSE1_UNITS; ++j) {
                current_reconstructed_i += current_decoder_dense1_output_for_batch_sample[j] * trainable_decoder_dense2_weights[j * WINDOW_SIZE + i];
            }

            // 计算该输出维度 i 的误差 (重建值 - 目标值)
            float error = current_reconstructed_i - learning_pca_data_buffer[b][i]; // (y_pred - target)

            // 累加梯度 for bias[i]
            // dL/db_i = error
            gradient_bias_sum[i] += error;

            // 累加梯度 for weights connected to output i
            // dL/dw_ji = error * input_j (input_j 是 current_decoder_dense1_output_for_batch_sample[j])
            for (int j = 0; j < DECODER_DENSE1_UNITS; ++j) {
                gradient_weights_sum[j * WINDOW_SIZE + i] += error * current_decoder_dense1_output_for_batch_sample[j];
            }
        }
    }

    // 3. 更新权重和偏置
    // 除以 LEARN_BATCH_SIZE 取平均梯度，乘以 LEARNING_RATE
    for (int i = 0; i < WINDOW_SIZE; ++i) {
        trainable_decoder_dense2_bias[i] -= LEARNING_RATE * (gradient_bias_sum[i] / LEARN_BATCH_SIZE);
    }
    for (int i = 0; i < DECODER_DENSE1_UNITS * WINDOW_SIZE; ++i) {
        trainable_decoder_dense2_weights[i] -= LEARNING_RATE * (gradient_weights_sum[i] / LEARN_BATCH_SIZE);
    }

    MicroPrintf("Online learning complete.\n");
}


// ======================================================================
//                          >>> Arduino 主函数 <<<
// ======================================================================

void setup() {
    Serial.begin(115200);
    while (!Serial); // 等待串口连接

    // 初始化 IMU
    if (!IMU.begin()) {
        MicroPrintf("Failed to initialize IMU!\n");
        while (1);
    }
    MicroPrintf("IMU initialized.\n");

    // 设置 TFLite Micro 操作解析器
    // 确保这里的操作与您的 encoder_model.h 中实际使用的操作匹配
    // 如果编码器只包含全连接层，AddFullyConnected() 就足够了
    static tflite::MicroMutableOpResolver<5> micro_op_resolver; 
    micro_op_resolver.AddFullyConnected();
    // 根据您的编码器模型实际使用的操作添加，例如：
    // micro_op_resolver.AddMean(); 
    // micro_op_resolver.AddReshape();
    // micro_op_resolver.AddConv2D(); 
    // micro_op_resolver.AddMaxPool2D(); 

    // 加载 TFLite 模型 (编码器)
    encoder_model = tflite::GetModel(encoder_tflite);
    if (encoder_model->version() != TFLITE_SCHEMA_VERSION) {
        MicroPrintf("Model schema version mismatch! Expected %d, got %d.\n",
                    TFLITE_SCHEMA_VERSION, encoder_model->version());
        while (1);
    }

    // 创建 TFLite 解释器
    static tflite::MicroInterpreter static_encoder_interpreter(
        encoder_model, micro_op_resolver, tensor_arena, kTensorArenaSize);
    encoder_interpreter = &static_encoder_interpreter;

    // 分配张量
    TfLiteStatus allocate_status = encoder_interpreter->AllocateTensors();
    if (allocate_status != kTfLiteOk) {
        MicroPrintf("Encoder tensor allocation failed!\n");
        while (1);
    }

    // 获取输入和输出张量
    encoder_input = encoder_interpreter->input(0);
    encoder_output = encoder_interpreter->output(0);

    // 检查输入输出张量类型和尺寸
    if (encoder_input->type != kTfLiteFloat32 || encoder_input->bytes != WINDOW_SIZE * sizeof(float)) {
        MicroPrintf("Encoder input tensor type or size mismatch! Expected float32, size %d. Got type %d, size %d.\n",
                    WINDOW_SIZE * sizeof(float), encoder_input->type, encoder_input->bytes);
        while (1);
    }
    if (encoder_output->type != kTfLiteFloat32 || encoder_output->bytes != EMBEDDING_UNITS * sizeof(float)) {
        MicroPrintf("Encoder output tensor type or size mismatch! Expected float32, size %d. Got type %d, size %d.\n",
                    EMBEDDING_UNITS * sizeof(float), encoder_output->type, encoder_output->bytes);
        while (1);
    }

    MicroPrintf("TFLite Micro encoder initialized.\n");
    printTrainableBias(); // 打印初始偏置和部分权重
}

void loop() {
    float x, y, z;

    // 读取传感器数据
    if (IMU.accelerationAvailable()) {
        IMU.readAcceleration(x, y, z);

        // 步骤 1: 将原始数据添加到窗口缓冲区
        sensor_data_window[window_index][0] = x;
        sensor_data_window[window_index][1] = y;
        sensor_data_window[window_index][2] = z;

        // 步骤 2: 对当前样本进行预处理 (标准化 + PCA)
        preprocess_data(x, y, z, pca_data_window[window_index]);
        
        window_index++;

        if (window_index >= WINDOW_SIZE) {
            window_index = 0; // 重置索引，形成循环缓冲区
            window_is_full = true;
        }

        // 只有当窗口数据足够时才进行推理
        if (window_is_full) {
            // 步骤 3: 运行编码器
            run_encoder();

            // 步骤 4: 运行解码器 (C++实现)
            run_decoder();

            // 步骤 5: 计算重建误差 (MAE)
            float mae = calculate_mae(pca_data_window, reconstructed_output, WINDOW_SIZE);

            // 步骤 6: 异常检测
            if (mae > ANOMALY_THRESHOLD) {
                Serial.print("Anomaly Detected! MAE: ");
                Serial.println(mae, 6);
            } else {
                Serial.print("Normal. MAE: ");
                Serial.println(mae, 6);

                // 步骤 7: 在线学习 (只对"正常"数据进行)
                // 如果误差足够小，可以认为当前样本是新的“正常”样本
                if (mae < ANOMALY_THRESHOLD * LEARN_THRESHOLD_FACTOR) {
                    // 将当前样本添加到学习缓冲区
                    // 确保在存储之前，pca_data_window 是整个窗口的完整数据
                    // 这里我们假设 pca_data_window 每次更新都是一个完整的窗口
                    // learning_pca_data_buffer 应该存储完整的窗口数据
                    for (int i = 0; i < WINDOW_SIZE; ++i) {
                        // 在此之前，pca_data_window[window_index] 已经被更新为当前样本的PCA值
                        // 但 learning_pca_data_buffer 需要的是一个完整的窗口
                        // 最简单的方式是直接复制当前的 pca_data_window
                        learning_pca_data_buffer[learning_buffer_index][i] = pca_data_window[i];
                    }

                    for (int i = 0; i < EMBEDDING_UNITS; ++i) {
                        learning_embedding_buffer[learning_buffer_index][i] = embedding_output[i];
                    }
                    learning_mae_buffer[learning_buffer_index] = mae; // 可以选择存储MAE，但当前代码没有使用

                    learning_buffer_index++;

                    // 如果学习缓冲区满了，执行一次权重和偏置更新
                    if (learning_buffer_index >= LEARN_BATCH_SIZE) {
                        runOnlineLearning(); // ！！！ 调用新的函数 ！！！
                        printTrainableBias(); // 打印更新后的偏置和部分权重
                        learning_buffer_index = 0; // 清空缓冲区
                    }
                }
            }
        }
    }
    delay(10); // 根据传感器采样率和WINDOW_SIZE调整延迟
}